#!/usr/bin/env bash
################################################################################
#
# MacOS Homebrew-based PHP Xdebug toggle.
#
################################################################################

set -euo pipefail
IFS=$'\n\t'

# -------------------------------------------------------------------------------
# Defines read-only script variables.
# -------------------------------------------------------------------------------
readonly APP_SCRIPT=$(basename "${0}")

# -------------------------------------------------------------------------------
# Sets flags which can be overridden by user input.
# Default values are below.
# -------------------------------------------------------------------------------
declare DEBUG=false
declare QUIET=false
declare RESTART=true
declare -a ARGS=()

# -------------------------------------------------------------------------------
# Program Usage
# -------------------------------------------------------------------------------
app_usage() {
    printf "\n"
    printf "%s\n" "Usage:"
    printf "  %s [options...] <command>\n" "${APP_SCRIPT}"
    printf "\n"
    printf "%s\n" "Options:"
    printf "  -d, --debug             Runs script in BASH debug mode\n"
    printf "  -h, --help              Display this help and exit\n"
    printf "  -n, --no-restart        Do not restart PHP service\n"
    printf "  -q, --quiet             Quiet (no output)\n"
    printf "\n"
    printf "%s\n" "Commands:"
    printf "  on                      Enable Xdebug\n"
    printf "  off                     Disable Xdebug\n"
    printf "\n"
}

# -------------------------------------------------------------------------------
# Parse Program Options
# -------------------------------------------------------------------------------
app_options() {
    local options=()
    local opt_string=h

    # normalize options
    # breaking -ab into -a -b when needed and --foo=bar into --foo bar
    while (("$#")); do
        case "${1}" in
        # if option is of type -ab
        -[!-]?*)
            # loop over each character starting with the second
            for ((i = 1; i < "${#1}"; i++)); do
                c="${1:i:1}"
                options+=("-${c}") # add current char to options
                # if option takes a required argument, and it's not the last char make
                # the rest of the string its argument
                if [[ "${opt_string}" == *"${c}:"* && "${1:i+1}" ]]; then
                    options+=("${1:i+1}")
                    break
                fi
            done
            ;;
        # if option is of type --foo=bar
        --?*=*)
            options+=("${1%%=*}" "${1#*=}")
            ;;
        # add --endopts for --
        --)
            options+=(--endopts)
            ;;
        # otherwise, nothing special
        *)
            options+=("${1}")
            ;;
        esac
        shift
    done
    if [[ "${#options[@]}" -ne 0 ]]; then
        set -- "${options[@]}"
    fi
    unset options

    # handle positional arguments
    while [[ "${1:-}" == -?* ]]; do
        case "${1}" in
        -h | --help)
            app_usage >&2
            app_exit
            ;;
        -d | --debug)
            DEBUG=true
            ;;
        -q | --quiet)
            QUIET=true
            ;;
        -n | --no-restart)
            RESTART=false
            ;;
        --endopts)
            shift
            break
            ;;
        *)
            app_error "$(printf "invalid option '%s'" "${1}")"
            app_fatal "try '%s --help' for more information." "${APP_SCRIPT}"
            ;;
        esac
        shift
    done

    # store the remaining user input as arguments
    ARGS+=("$@")
}

# -------------------------------------------------------------------------------
# Any actions that should be taken if the script is prematurely
# exited. Always call this function at the top of your script.
# -------------------------------------------------------------------------------
app_cleanup() {
    # re-enable echoing of terminal input
    stty echo
    # shows the input cursor
    tput cnorm
    echo -n
}

# -------------------------------------------------------------------------------
# Non-destructive exit for when script exits naturally. Add this function at
# the end of the script.
#
# Arguments:
#   $1 (optional) - Exit code (defaults to 0)
# -------------------------------------------------------------------------------
app_exit() {
    app_cleanup
    exit "${1:-0}"
}

# -------------------------------------------------------------------------------
# Any actions that should be taken if the script is prematurely exited. Always
# call this function at the top of your script.
# -------------------------------------------------------------------------------
app_fail() {
    app_cleanup
    if [[ "${DEBUG}" == "true" ]] || [[ "${DEBUG}" == "1" ]]; then
        printf "\nTrapped exit in function: '%s'." "${FUNCNAME[*]}"
    else
        printf "\nExiting."
    fi
    app_exit 1
}

# -------------------------------------------------------------------------------
# Print error message.
#
# Arguments:
#   $1 (required) - The message to print
# -------------------------------------------------------------------------------
app_error() {
    printf "%s: %s\n" "${APP_SCRIPT}" "${1}"
}

# -------------------------------------------------------------------------------
# Print error message and exit with error code.
#
# Arguments:
#   $1 (required) - The message to print
# -------------------------------------------------------------------------------
app_fatal() {
    printf "%s: %s\n\n" "${APP_SCRIPT}" "${1}"
    app_exit 1
}

# -------------------------------------------------------------------------------
# Main Program
# -------------------------------------------------------------------------------
app_run() {
    if ! hash brew 2>/dev/null; then
        app_fatal "The 'brew' program is a dependency and cannot be found."
    fi
    if ! hash php 2>/dev/null; then
        app_fatal "The 'php' program is a dependency and cannot be found."
    fi
    if ! hash php-config 2>/dev/null; then
        app_fatal "The 'php-config' program is a dependency and cannot be found."
    fi

    PHP_VERSION=$(php -r "\$v=explode('.', PHP_VERSION ); echo implode('.', array_splice(\$v, 0, -1));")
    XDEBUG_PATH="$(brew --prefix)/etc/php/${PHP_VERSION}/conf.d"
    XDEBUG_CONF="${XDEBUG_PATH}/ext-xdebug.ini"
    PHP_EXT_DIR="$(php-config --extension-dir)"

    if [ ! -f "${PHP_EXT_DIR}"/xdebug.so ]; then
        app_fatal "Xdebug for PHP ${PHP_VERSION} has not been installed via PECL."
    fi

    if [ ! -f "${XDEBUG_CONF}" ] && [ ! -f "${XDEBUG_CONF}.disabled" ]; then
        app_error "The Xdebug INI file was not found at '${XDEBUG_CONF}'"
        app_fatal "Please check that the extension was installed via PECL."
    fi

    # reset argument array
    set -- "${ARGS[@]:-()}"

    case "${ARGS:-()}" in
    off)
        shift
        app_toggle "off"
        ;;
    on)
        shift
        app_toggle "on"
        ;;
    *)
        app_usage
        ;;
    esac
}

# -------------------------------------------------------------------------------
# Toggle Xdebug configuration.
#
# Arguments:
#   $1 (required) - The command to run
# -------------------------------------------------------------------------------
app_toggle() {
    local command="${1}"
    local skip="false"
    local status="disabled"

    if [ -f "${XDEBUG_CONF}" ] && [ -f "${XDEBUG_CONF}.disabled" ]; then
        rm -f "${XDEBUG_CONF}.disabled"
        status="enabled"
    fi

    if [ "${command}" == "on" ]; then
        if [ -f "${XDEBUG_CONF}.disabled" ]; then
            mv -f "${XDEBUG_CONF}.disabled" "${XDEBUG_CONF}" 2>/dev/null
        else
            skip="true"
        fi
        status="enabled"
    elif [ "${command}" == "off" ]; then
        if [ -f "${XDEBUG_CONF}" ]; then
            mv -f "${XDEBUG_CONF}" "${XDEBUG_CONF}.disabled" 2>/dev/null
        else
            skip="true"
        fi
        status="disabled"
    fi

    if [ "${RESTART}" == "false" ]; then
        printf "\nXdebug has been %s. PHP will not be restarted." "${status}"
    elif [ "${skip}" == "false" ]; then
        printf "\nXdebug has been %s, restarting PHP..." "${status}"
        brew services stop php@"${PHP_VERSION}" >/dev/null
        brew services start php@"${PHP_VERSION}" >/dev/null
    fi

    printf "\nUsing PHP %s with Xdebug %s\n\n" "${PHP_VERSION}" "${status}"
}

################################################################################
#
# RUN THE SCRIPT
# Nothing should be edited below this block.
#
################################################################################

# trap exits with your cleanup function
trap app_fail SIGINT SIGQUIT
trap app_exit INT TERM EXIT

# parse arguments passed to script
app_options "$@"

# run in debug mode, if set
[[ "${DEBUG}" == "true" ]] && set -x

# main script run
app_run

# clean exit
app_exit 0
